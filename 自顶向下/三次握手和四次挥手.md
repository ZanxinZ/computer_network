# 计算机网络——握手与挥手

## 三次握手

1. 端系统 A 发送带有Seq= A_isn  、SYN=1 的数据报给端系统 B，请求建立连接。
2. 端系统 B 收到之后，建立连接，把带有 SYN=1 、ACK=A_isn+1、Seq=B_isn 的数据报，发送给端系统 A。
3. 端系统 A 收到之后，发送带有 SYN=0、seq=A_isn+1、ACK 的数据报给端系统 B，端系统收到之后开始传输数据。  

（发送的 ACK num 是自己刚刚收到的SYN+1）

SYN 同步序列编号（Synchronize Sequence Numbers）

ISN 初始化序列编号（Initial Sequence Numbers）：

​	发送方的**字节数据编号的原点**，让对方生成一个**合法的接收窗口**。

​	动态随机，（为了避免被第三方猜到，从而被第三方伪造的RST报文reset）

### 三次握手中问题

- 第一次握手不能携带数据：三次握手还没有完成。

- 能不能让数据在第一次握手缓存下来，然后握手成功之后再接收数据？

  不能，会加大SYN Flood 攻击的风险。

- 第三次握手可以携带数据：因为能够发出第三次握手报文的主机，肯定接收到第二次握手的报文，而伪造主机是收不到第二次握手报文的。尽管服务器端状态还没有 “establish”，接收到第三次握手报文的瞬间状态就会切换为 “establish”，数据接收按正常流程走就可以。 

### TCP连接

用于保证可靠性和流量控制维护的状态信息，这些信息包括**Socket、序列号、窗口大小**称为连接。

三次握手原因：

- 可以阻止重复历史连接的初始化。

  假设有端系统 A 有一条历史请求 k ,由于网络延迟，A 已经抛弃了 k，并且A 另外发起请求 z。但过了一会儿端系统B 收到了 k（认为是第二次握手）。

  - 如果是两次握手，那么端系统B会马上基于 k 所规定的窗口，开启传输数据的服务，A 已经抛弃了 k ,而 B 去初始化 k ,就浪费了 B 的资源。
  - 如果是三次握手，那么端系统 B 不会马上传输数据，而是把把带有 SYN=1 、ACK=A_isn+1、Seq=B_isn 的数据报发送给A，要收到第三次握手报文后才开始传输。而 A 收到关于 k 的回复，是不愿意的，所以发送 RST,让 B 重新开始连接。就可以使得 B 把注意力放在下一条请求上，也就是 z 。

- 可以同步双方的初始序列号。

  ![image-20210202143406025](四次握手简化为三次.png)

  两次握手只保证了 A 的序列号能被 B 接收，而无法保证B的序列号能被 A 接收。（A 确认了自己**收发**正常，B 只确认了自己**收**正常），所以需要三次握手。

- 避免资源浪费

## 四次挥手

![四次挥手](四次挥手.png)

挥手需要四次，是因为服务端在发送ACK 和 FIN之间的时间里，可能有传输任务未完成，需要等待传输完成，才能关闭连接、发送FIN信号。

